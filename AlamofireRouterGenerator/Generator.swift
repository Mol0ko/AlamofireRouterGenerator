//
//  Generator.swift
//  AlamofireRouterGenerator
//
//  Created by Nikita_Krasavin    on 24.07.17.
//  Copyright Â© 2017 Appcraft. All rights reserved.
//

import Foundation
import AppKit

class Generator {
    
    private var PostmanModel: PostmanModel
    
    init(postmanModel: PostmanModel){
        PostmanModel = postmanModel
    }
    
    func generateSwift3Router() -> String? {
        
        // 1 - recognize folders and requests in postman collection:
        let folders = recognizeFolders()
        let allRequests = recognizeAllRequests(folders: folders)
        let (folderedRequests, topLevelRequests) = recognizeFolderedRequests(folders: folders, allRequests: allRequests)
        
        // 2 - generate requests with parameters:       (first part of router enum)
        let requestsNamesSection = generateRequestsNamesWithParameters(folders: folderedRequests, topRequests: topLevelRequests)
        // 3 - generate var 'method':
        let methodSection = generateMethodSection(allRequests: allRequests)
        // 4 - generate vars 'baseURL' and 'path':
        let baseUrl = generateBaseUrlSection(allRequests: allRequests) ?? ""
        let pathString = generatePathSection(allRequests: allRequests)
        // 5 - generate asURLRequest() func:
        let asUrlRequestFuncString = generateasUrlRequestFuncSection(allRequests: allRequests)
        
        return routerHeaderString + requestsNamesSection + methodSection + baseUrl + pathString + asUrlRequestFuncString + "\n}"
    }
    
    //MARK: - private funcs
    //MARK: -
    
    //MARK: - prepare objects
    private func recognizeFolders() -> [ItemResponse] {
        var folders = [ItemResponse]()
        
        //recognize folders in top level of postman collection:
        PostmanModel.item?.forEach {
            if $0.isFolder {
                folders.append($0)
            }
        }
        
        //if no folders - return empty array:
        if folders.count == 0 {
            return [ItemResponse]()
        }
        
        //else watch for other inner folders:
        var foldersCount = folders.count
        repeat {
            foldersCount = folders.count
            folders.forEach {
                $0.item?.forEach {
                    if $0.isFolder, !$0.watched {
                        folders.append($0)
                        $0.watched = true
                    }
                }
            }
        } while foldersCount != folders.count
        
        return folders
    }
    
    private func recognizeAllRequests(folders: [ItemResponse]) -> [ItemResponse] {
        var requests = [ItemResponse]()
        
        //recognize requests in top level of postman collection:
        PostmanModel.item?.forEach {
            if !$0.isFolder {
                requests.append($0)
            }
        }
        
        //recognize requests in folders:
        folders.forEach {
            $0.item?.forEach({
                if !$0.isFolder {       //if is request
                    requests.append($0)
                }}
            )
        }
        return requests
    }
    
    private func recognizeFolderedRequests(folders: [ItemResponse], allRequests: [ItemResponse]) -> ([FolderWithRequests], [ItemResponse]) {
        var folderedRequests = [FolderWithRequests]()
        
        if folders.count > 0 {
            folders.forEach {
                let folder = $0
                var requestsInFolder = [ItemResponse]()
                folder.item?.forEach({
                    if !$0.isFolder {
                        requestsInFolder.append($0)
                    }
                })
                folderedRequests.append(FolderWithRequests(folderName: folder.name ?? "", requestsInFolder: requestsInFolder))
            }
        } else {
            let rootFolder = FolderWithRequests(folderName: "root", requestsInFolder: allRequests)
            folderedRequests.append(rootFolder)
        }
        
        var topLevelRequests = [ItemResponse]()
        
        //recognize requests in top level of postman collection:
        PostmanModel.item?.forEach {
            if !$0.isFolder {
                topLevelRequests.append($0)
            }
        }
        return (folderedRequests, topLevelRequests)
    }
    
    private func getBaseURL(allRequests: [ItemResponse]) -> String? {
        var urlsArray = [String]()
        allRequests.forEach {
            if let url = $0.request?.url {
                urlsArray.append(url)
            }
        }
        if urlsArray.isEmpty {
            return nil
        }
        var commonPrefix = ""
        urlsArray.forEach {
            let newCommonPrefix = urlsArray.first!.commonPrefix(with: $0)
            if commonPrefix != newCommonPrefix {
                commonPrefix = newCommonPrefix
            }
        }
        return commonPrefix
    }
    
    //MARK: - generate swift enum string:
    
    private let routerHeaderString = "//\n// Generated by AlamofireRouterGenerator v \(Bundle.main.infoDictionary?["CFBundleShortVersionString"] ?? "0.1.0") https://github.com/Mol0ko/AlamofireRouterGenerator.git\n//\n\n\nimport Alamofire\n\nenum NetworkRouter: URLRequestConvertible {"
    
    private func generateRequestsNamesWithParameters(folders: [FolderWithRequests], topRequests: [ItemResponse]) -> String {
        var requestsString = "\n\n"
        
        if topRequests.count > 0 {
            requestsString.append("\t//root\n")
        }
        for req in topRequests {
            guard let _ = req.name else {
                return ""
            }
            let parametersString = req.hasParameters ? "(parameters: [String: Any])" : ""
            requestsString.append("\tcase \(req.getNameForRouter())\(parametersString)\n")
        }
        
        for folder in folders {
            //create comment with folder name
            let commenWithFolderName = "\t//\(folder.name)\n"
            requestsString.append(commenWithFolderName)
            
            //create request case for each request in folder
            for req in folder.requests {
                guard let _ = req.name else {
                    return ""
                }
                let parametersString = req.hasParameters ? "(parameters: [String: Any])" : ""
                requestsString.append("\tcase \(req.getNameForRouter())\(parametersString)\n")
            }
        }
        return requestsString
    }
    
    private func generateMethodSection(allRequests: [ItemResponse]) -> String {
        var getString = ""
        var postString = ""
        var putString = ""
        var deleteString = ""
        var patchString = ""
        
        for req in allRequests {
            if let method = req.request?.method {
                switch method {
                case .get:
                    getString.append("\n\t\t\t.\(req.getNameForRouter()),")
                    break
                case .post:
                    postString.append("\n\t\t\t.\(req.getNameForRouter()),")
                    break
                case .delete:
                    deleteString.append("\n\t\t\t.\(req.getNameForRouter()),")
                    break
                case .put:
                    putString.append("\n\t\t\t.\(req.getNameForRouter()),")
                    break
                case .patch:
                    patchString.append("\n\t\t\t.\(req.getNameForRouter()),")
                    break
                default:
                    break
                }
            }
        }
        
        if !getString.isEmpty {
            getString = "\t\tcase \(getString.substring(to: getString.index(getString.endIndex, offsetBy: -1))):\n\t\t\treturn .get\n"
        }
        if !postString.isEmpty {
            postString = "\t\tcase \(postString.substring(to: postString.index(postString.endIndex, offsetBy: -1))):\n\t\t\treturn .post\n"
        }
        if !putString.isEmpty {
            putString = "\t\tcase \(putString.substring(to: putString.index(putString.endIndex, offsetBy: -1))):\n\t\t\treturn .put\n"
        }
        if !deleteString.isEmpty {
            deleteString = "\t\tcase \(deleteString.substring(to: deleteString.index(deleteString.endIndex, offsetBy: -1))):\n\t\t\treturn .delete\n"
        }
        if !patchString.isEmpty {
            patchString = "\t\tcase \(patchString.substring(to: patchString.index(patchString.endIndex, offsetBy: -1))):\n\t\t\treturn .patch\n"
        }
        
        let methodsString = "\n\n\tvar method: HTTPMethod {\n\t\tswitch self {\n\(getString)\(postString)\(putString)\(deleteString)\(patchString)\t\t}\n\t}"
        
        return methodsString
    }
    
    private func generateBaseUrlSection(allRequests: [ItemResponse]) -> String? {
        guard let url = getBaseURL(allRequests: allRequests) else {
            return nil
        }
        let baseUrlString = "\n\n\tvar baseURL: String {\n\t\treturn \"\(url)\"\n\t}"
        return baseUrlString
    }
    
    private func generatePathSection(allRequests: [ItemResponse]) -> String {
        var cases = ""
        let baseUrl = getBaseURL(allRequests: allRequests) ?? ""
        for req in allRequests {
            if let url = req.request?.url {
                let newCase = url.getQueryStringWithoutParameters().replacingOccurrences(of: baseUrl, with: "")
                cases.append("\t\tcase .\(req.getNameForRouter()):\n\t\t\treturn \"\(newCase)\"\n")
            }
        }
        let pathsString = "\n\n\tvar path: String {\n\t\tswitch self {\n\(cases)\t\t}\n\t}"
        
        return pathsString
    }
    
    public func generateasUrlRequestFuncSection(allRequests: [ItemResponse]) -> String {
        let baseUrlSetting = (getBaseURL(allRequests: allRequests) != nil) ? "\t\tlet url = try baseURL.asURL()\n" : ""
        let asUrlRequestFields = baseUrlSetting + "\t\tvar urlRequest = URLRequest(url: url.appendingPathComponent(path))\n\t\turlRequest.httpMethod = method.rawValue\n\t\turlRequest.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")"
        var cases = ""
        
        for req in allRequests.filter({ $0.hasParameters }) {
            let endOfCase = allRequests.last?.getNameForRouter() == req.getNameForRouter() ? "(let parameters):" : "(let parameters),\n"
            cases.append("\t\t\t." + req.getNameForRouter() + endOfCase)
        }
        
        let switchString = "\n\n\t\tswitch self {\n\t\t//set parameters for requests with parameters:\n\t\tcase\n\(cases)\n\t\t\turlRequest.httpBody = try JSONSerialization.data(withJSONObject: parameters)\n\t\t\tbreak\n\t\tdefault:\n\t\t\t\tbreak\n\t\t}\n\t\treturn urlRequest\n\t}"
        
        return "\n\n//MARK: - URLRequestConvertible\n//MARK: -\n\n\tfunc asURLRequest() throws -> URLRequest {\n" + asUrlRequestFields + switchString
    }
}
